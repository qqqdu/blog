---
title: 你为什么看不懂源码之Vue 3.0 点线成面
---
距离上一篇已经过去了好久......  

## 先唠会儿嗑

之前大概了解了 响应式原理、让普通属性变成响应式数据的 ref、effect 的实现以及 计算属性的包装。  
不知道有没有人和我有一样的迷惑：单一功能的代码拿出来是可以看懂的，但放眼全局，还是有些凌乱，并且，从代码的实现上可以理解其运行流程，但不知道它为何这样实现？  
简单概括下这种阶段：只知其然，不知其所以然。  

如果我们能从框架作者的角度出发，全局去考虑代码的结构、各种模块的作用或者解决了什么痛点，这样会不会更深入一点。所以这篇，我想探索下如何 「点线成面」。(ps: 写这一段时，我不知道下文该写什么。)  

## 你真的懂了吗？  

我在写见不得人的私人博客时，经常会起这个标题来问自己。生怕自己不懂装懂，每到这个标题的时候，都会反省下是否真的懂了。  

因为之前的文章写的不全面，仅仅讲“方法论”，一篇就挑了一两个 `demo`，你最好通过我前几篇文章的“方法”，将源码中的测试用例都走一遍。这保证了读这篇文章的流畅度。（我也要去走一遍，你可以先收藏文章，读完用例之后接着看。  

## 假如你是作者

你的需求是开发 `reactive` 模块，它是干什么的呢？将变量生成响应式数据。  

响应式数据被更改时，需要做一些反应。那怎么能检测响应式的变更呢？在谈这个问题前，得先罗列下，变量有哪些类型？  

### 变量的类型  

#### 基本类型

String Number Symbol

形如:  

```javascript
let a = 2
let b = 'lalla'
let c = Symbol('cObj')
```

#### 普通对象

形如：

```javascript
let obj = { name: 'obj' }
```

#### 集合对象

Map WeakMap Set WeakSet
形如

```javascript
let map = new Map([{name: 'map'}])
let set = new Set([1,2,3])
```

基本上是这三类，但这三类可能交织纵横，互相“包庇”！我太难了。

### 拦截

既然分出了变量的类型，逐一拦截，然后再做“反应”就行了。先从普通变量谈起。

#### 普通变量拦截

不管是 `Object.defineProperty()` 还是 `Proxy()`，拦截的都是对象，所以通过这两种方式来拦截普通变量肯定行不通，但我们可以包装它，从而实现拦截。最简单的方式便是对象的特性“存取器”。

```javascript
let a = 3
const b = {
  get value() {
     return a
  },
  set value(val) {
     a = val
  }
}
```

这块儿的实现便是 `Ref.ts`

### 普通对象的拦截

这在 Vue2.0 中已经实现过了，用的 ES5 的 `Object.defineProperty`。直接拿来用就行了。  

> A:  等等，不能用！！  

> B: 为什么？  

>A: Object.defineProperty 在拦截对象时，需要遍历其 key 值。如果对象层级深，还要递归的遍历。
```javascript
Object.keys(obj).forEach((key) => {
  Object.defineProperty(obj, key, handlers)
})
```
>A： 它还拦截不了数组的方法，想拦截还得做 hack，包装 push\pop......操作。  

>B: 那咋整  

>A: Proxy 呀，以上问题它都能迎刃而解，具体我们不是在往期文章分析过了么。  

这样，普通对象也能拦截到了。  

### 集合的拦截

`Proxy` 这么牛，集合应该也能拦截呀。不幸的时，集合的各种方法都不能被 Proxy 拦截。

## 参考文献  
[ecma](https://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects)